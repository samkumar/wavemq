// Code generated by protoc-gen-go. DO NOT EDIT.
// source: wavemq.proto

/*
Package mqpb is a generated protocol buffer package.

Version 1.0

It is generated from these files:
	wavemq.proto
	eapi.proto

It has these top-level messages:
	ConnectionStatusParams
	ConnectionStatusResponse
	QueryParams
	QueryMessage
	PeerQueryParams
	PeerUnsubscribeParams
	PeerUnsubscribeResponse
	PeerPublishParams
	PeerPublishResponse
	PeerSubscriptionTBS
	PeerSubscribeParams
	PublishParams
	PublishResponse
	MessageTBS
	Message
	PayloadObject
	JEDIData
	Payload
	SubscribeParams
	SubscriptionMessage
	CompactProofParams
	CompactProofResponse
	RevokeParams
	RevokeResponse
	ResolveReverseNameParams
	ResolveReverseNameResponse
	MarkEntityInterestingParams
	MarkEntityInterestingResponse
	CreateNameDeclarationParams
	CreateNameDeclarationResponse
	ResolveNameParams
	NameDeclaration
	ResolveNameResponse
	ResolveHashParams
	ResolveHashResponse
	InspectParams
	InspectResponse
	ListLocationsParams
	ListLocationsResponse
	CreateEntityParams
	CreateEntityResponse
	Entity
	CreateAttestationParams
	ResyncPerspectiveGraphParams
	ResyncPerspectiveGraphResponse
	SyncParams
	EncryptMessageParams
	EncryptMessageResponse
	DecryptMessageParams
	DecryptMessageResponse
	SyncResponse
	StorageDriverStatus
	CreateAttestationResponse
	PublishEntityParams
	PublishEntityResponse
	PublishAttestationParams
	PublishAttestationResponse
	AddAttestationParams
	AddAttestationResponse
	LookupAttestationsParams
	LookupAttestationsResponse
	Error
	Perspective
	Location
	LocationURI
	EntitySecret
	Attestation
	AttestationBody
	AttestationValidity
	EntityValidity
	NameDeclarationValidity
	Policy
	TrustLevelPolicy
	RTreePolicy
	RTreePolicyStatement
	BuildRTreeProofParams
	BuildRTreeProofResponse
	VerifyProofParams
	VerifyProofResponse
	Proof
	ProofPath
*/
package mqpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ConnectionStatusParams struct {
}

func (m *ConnectionStatusParams) Reset()                    { *m = ConnectionStatusParams{} }
func (m *ConnectionStatusParams) String() string            { return proto.CompactTextString(m) }
func (*ConnectionStatusParams) ProtoMessage()               {}
func (*ConnectionStatusParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ConnectionStatusResponse struct {
	TotalPeers     int32 `protobuf:"varint,1,opt,name=totalPeers" json:"totalPeers,omitempty"`
	ConnectedPeers int32 `protobuf:"varint,2,opt,name=connectedPeers" json:"connectedPeers,omitempty"`
}

func (m *ConnectionStatusResponse) Reset()                    { *m = ConnectionStatusResponse{} }
func (m *ConnectionStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectionStatusResponse) ProtoMessage()               {}
func (*ConnectionStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ConnectionStatusResponse) GetTotalPeers() int32 {
	if m != nil {
		return m.TotalPeers
	}
	return 0
}

func (m *ConnectionStatusResponse) GetConnectedPeers() int32 {
	if m != nil {
		return m.ConnectedPeers
	}
	return 0
}

type QueryParams struct {
	Perspective *Perspective `protobuf:"bytes,1,opt,name=perspective" json:"perspective,omitempty"`
	Namespace   []byte       `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Uri         string       `protobuf:"bytes,3,opt,name=uri" json:"uri,omitempty"`
	// If specified, this proof will be used instead of building one
	CustomProofDER []byte `protobuf:"bytes,4,opt,name=customProofDER,proto3" json:"customProofDER,omitempty"`
}

func (m *QueryParams) Reset()                    { *m = QueryParams{} }
func (m *QueryParams) String() string            { return proto.CompactTextString(m) }
func (*QueryParams) ProtoMessage()               {}
func (*QueryParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *QueryParams) GetPerspective() *Perspective {
	if m != nil {
		return m.Perspective
	}
	return nil
}

func (m *QueryParams) GetNamespace() []byte {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *QueryParams) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *QueryParams) GetCustomProofDER() []byte {
	if m != nil {
		return m.CustomProofDER
	}
	return nil
}

type QueryMessage struct {
	Error   *Error   `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Message *Message `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *QueryMessage) Reset()                    { *m = QueryMessage{} }
func (m *QueryMessage) String() string            { return proto.CompactTextString(m) }
func (*QueryMessage) ProtoMessage()               {}
func (*QueryMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *QueryMessage) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *QueryMessage) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

type PeerQueryParams struct {
	SourceEntity []byte `protobuf:"bytes,1,opt,name=sourceEntity,proto3" json:"sourceEntity,omitempty"`
	Namespace    []byte `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Uri          string `protobuf:"bytes,3,opt,name=uri" json:"uri,omitempty"`
	Signature    []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	ProofDER     []byte `protobuf:"bytes,5,opt,name=proofDER,proto3" json:"proofDER,omitempty"`
}

func (m *PeerQueryParams) Reset()                    { *m = PeerQueryParams{} }
func (m *PeerQueryParams) String() string            { return proto.CompactTextString(m) }
func (*PeerQueryParams) ProtoMessage()               {}
func (*PeerQueryParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PeerQueryParams) GetSourceEntity() []byte {
	if m != nil {
		return m.SourceEntity
	}
	return nil
}

func (m *PeerQueryParams) GetNamespace() []byte {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *PeerQueryParams) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *PeerQueryParams) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *PeerQueryParams) GetProofDER() []byte {
	if m != nil {
		return m.ProofDER
	}
	return nil
}

type PeerUnsubscribeParams struct {
	SourceEntity []byte `protobuf:"bytes,1,opt,name=sourceEntity,proto3" json:"sourceEntity,omitempty"`
	Id           string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
}

func (m *PeerUnsubscribeParams) Reset()                    { *m = PeerUnsubscribeParams{} }
func (m *PeerUnsubscribeParams) String() string            { return proto.CompactTextString(m) }
func (*PeerUnsubscribeParams) ProtoMessage()               {}
func (*PeerUnsubscribeParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PeerUnsubscribeParams) GetSourceEntity() []byte {
	if m != nil {
		return m.SourceEntity
	}
	return nil
}

func (m *PeerUnsubscribeParams) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type PeerUnsubscribeResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *PeerUnsubscribeResponse) Reset()                    { *m = PeerUnsubscribeResponse{} }
func (m *PeerUnsubscribeResponse) String() string            { return proto.CompactTextString(m) }
func (*PeerUnsubscribeResponse) ProtoMessage()               {}
func (*PeerUnsubscribeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PeerUnsubscribeResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type PeerPublishParams struct {
	Msg *Message `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
}

func (m *PeerPublishParams) Reset()                    { *m = PeerPublishParams{} }
func (m *PeerPublishParams) String() string            { return proto.CompactTextString(m) }
func (*PeerPublishParams) ProtoMessage()               {}
func (*PeerPublishParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PeerPublishParams) GetMsg() *Message {
	if m != nil {
		return m.Msg
	}
	return nil
}

type PeerPublishResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *PeerPublishResponse) Reset()                    { *m = PeerPublishResponse{} }
func (m *PeerPublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PeerPublishResponse) ProtoMessage()               {}
func (*PeerPublishResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PeerPublishResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type PeerSubscriptionTBS struct {
	SourceEntity []byte `protobuf:"bytes,1,opt,name=sourceEntity,proto3" json:"sourceEntity,omitempty"`
	Namespace    []byte `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Uri          string `protobuf:"bytes,3,opt,name=uri" json:"uri,omitempty"`
	Id           string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// This is the router that formed the subscription message
	RouterID string `protobuf:"bytes,5,opt,name=routerID" json:"routerID,omitempty"`
	// How long should this queue last if not actively drained
	// Should be > 1 minute to prevent disconnect of live queues
	// This is in seconds
	Expiry int64 `protobuf:"varint,6,opt,name=expiry" json:"expiry,omitempty"`
}

func (m *PeerSubscriptionTBS) Reset()                    { *m = PeerSubscriptionTBS{} }
func (m *PeerSubscriptionTBS) String() string            { return proto.CompactTextString(m) }
func (*PeerSubscriptionTBS) ProtoMessage()               {}
func (*PeerSubscriptionTBS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PeerSubscriptionTBS) GetSourceEntity() []byte {
	if m != nil {
		return m.SourceEntity
	}
	return nil
}

func (m *PeerSubscriptionTBS) GetNamespace() []byte {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *PeerSubscriptionTBS) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *PeerSubscriptionTBS) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PeerSubscriptionTBS) GetRouterID() string {
	if m != nil {
		return m.RouterID
	}
	return ""
}

func (m *PeerSubscriptionTBS) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type PeerSubscribeParams struct {
	Tbs       *PeerSubscriptionTBS `protobuf:"bytes,1,opt,name=tbs" json:"tbs,omitempty"`
	Signature []byte               `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	ProofDER  []byte               `protobuf:"bytes,3,opt,name=proofDER,proto3" json:"proofDER,omitempty"`
	// This is a unix timestamp in nanoseconds that this subscription should
	// expire at
	AbsoluteExpiry int64 `protobuf:"varint,4,opt,name=absoluteExpiry" json:"absoluteExpiry,omitempty"`
}

func (m *PeerSubscribeParams) Reset()                    { *m = PeerSubscribeParams{} }
func (m *PeerSubscribeParams) String() string            { return proto.CompactTextString(m) }
func (*PeerSubscribeParams) ProtoMessage()               {}
func (*PeerSubscribeParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PeerSubscribeParams) GetTbs() *PeerSubscriptionTBS {
	if m != nil {
		return m.Tbs
	}
	return nil
}

func (m *PeerSubscribeParams) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *PeerSubscribeParams) GetProofDER() []byte {
	if m != nil {
		return m.ProofDER
	}
	return nil
}

func (m *PeerSubscribeParams) GetAbsoluteExpiry() int64 {
	if m != nil {
		return m.AbsoluteExpiry
	}
	return 0
}

type PublishParams struct {
	Perspective *Perspective     `protobuf:"bytes,1,opt,name=perspective" json:"perspective,omitempty"`
	Namespace   []byte           `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Uri         string           `protobuf:"bytes,3,opt,name=uri" json:"uri,omitempty"`
	Content     []*PayloadObject `protobuf:"bytes,4,rep,name=content" json:"content,omitempty"`
	// If specified, the message will be encrypted
	EncryptionPartition [][]byte `protobuf:"bytes,5,rep,name=encryptionPartition,proto3" json:"encryptionPartition,omitempty"`
	// Should this message be persisted
	Persist bool `protobuf:"varint,6,opt,name=persist" json:"persist,omitempty"`
	// If specified, this proof will be used instead of building one
	CustomProofDER  []byte `protobuf:"bytes,7,opt,name=customProofDER,proto3" json:"customProofDER,omitempty"`
	EncryptWithJEDI bool   `protobuf:"varint,8,opt,name=encryptWithJEDI" json:"encryptWithJEDI,omitempty"`
}

func (m *PublishParams) Reset()                    { *m = PublishParams{} }
func (m *PublishParams) String() string            { return proto.CompactTextString(m) }
func (*PublishParams) ProtoMessage()               {}
func (*PublishParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PublishParams) GetPerspective() *Perspective {
	if m != nil {
		return m.Perspective
	}
	return nil
}

func (m *PublishParams) GetNamespace() []byte {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *PublishParams) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *PublishParams) GetContent() []*PayloadObject {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *PublishParams) GetEncryptionPartition() [][]byte {
	if m != nil {
		return m.EncryptionPartition
	}
	return nil
}

func (m *PublishParams) GetPersist() bool {
	if m != nil {
		return m.Persist
	}
	return false
}

func (m *PublishParams) GetCustomProofDER() []byte {
	if m != nil {
		return m.CustomProofDER
	}
	return nil
}

func (m *PublishParams) GetEncryptWithJEDI() bool {
	if m != nil {
		return m.EncryptWithJEDI
	}
	return false
}

type PublishResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }
func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()               {}
func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PublishResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type MessageTBS struct {
	SourceEntity   []byte           `protobuf:"bytes,1,opt,name=sourceEntity,proto3" json:"sourceEntity,omitempty"`
	SourceLocation *LocationURI     `protobuf:"bytes,2,opt,name=sourceLocation" json:"sourceLocation,omitempty"`
	Namespace      []byte           `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Uri            string           `protobuf:"bytes,4,opt,name=uri" json:"uri,omitempty"`
	Payload        []*PayloadObject `protobuf:"bytes,5,rep,name=payload" json:"payload,omitempty"`
	// The ID of the router/agent that formed this message
	OriginRouter string    `protobuf:"bytes,6,opt,name=originRouter" json:"originRouter,omitempty"`
	JediData     *JEDIData `protobuf:"bytes,7,opt,name=jediData" json:"jediData,omitempty"`
}

func (m *MessageTBS) Reset()                    { *m = MessageTBS{} }
func (m *MessageTBS) String() string            { return proto.CompactTextString(m) }
func (*MessageTBS) ProtoMessage()               {}
func (*MessageTBS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *MessageTBS) GetSourceEntity() []byte {
	if m != nil {
		return m.SourceEntity
	}
	return nil
}

func (m *MessageTBS) GetSourceLocation() *LocationURI {
	if m != nil {
		return m.SourceLocation
	}
	return nil
}

func (m *MessageTBS) GetNamespace() []byte {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *MessageTBS) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *MessageTBS) GetPayload() []*PayloadObject {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MessageTBS) GetOriginRouter() string {
	if m != nil {
		return m.OriginRouter
	}
	return ""
}

func (m *MessageTBS) GetJediData() *JEDIData {
	if m != nil {
		return m.JediData
	}
	return nil
}

type Message struct {
	Proof               *Proof      `protobuf:"bytes,1,opt,name=proof" json:"proof,omitempty"`
	ProofDER            []byte      `protobuf:"bytes,2,opt,name=proofDER,proto3" json:"proofDER,omitempty"`
	Tbs                 *MessageTBS `protobuf:"bytes,3,opt,name=tbs" json:"tbs,omitempty"`
	Signature           []byte      `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	EncryptionPartition [][]byte    `protobuf:"bytes,5,rep,name=encryptionPartition,proto3" json:"encryptionPartition,omitempty"`
	Timestamps          []int64     `protobuf:"varint,6,rep,packed,name=timestamps" json:"timestamps,omitempty"`
	Drops               []int64     `protobuf:"varint,7,rep,packed,name=drops" json:"drops,omitempty"`
	Persist             bool        `protobuf:"varint,8,opt,name=persist" json:"persist,omitempty"`
	ProofHash           []byte      `protobuf:"bytes,9,opt,name=proofHash,proto3" json:"proofHash,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Message) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *Message) GetProofDER() []byte {
	if m != nil {
		return m.ProofDER
	}
	return nil
}

func (m *Message) GetTbs() *MessageTBS {
	if m != nil {
		return m.Tbs
	}
	return nil
}

func (m *Message) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Message) GetEncryptionPartition() [][]byte {
	if m != nil {
		return m.EncryptionPartition
	}
	return nil
}

func (m *Message) GetTimestamps() []int64 {
	if m != nil {
		return m.Timestamps
	}
	return nil
}

func (m *Message) GetDrops() []int64 {
	if m != nil {
		return m.Drops
	}
	return nil
}

func (m *Message) GetPersist() bool {
	if m != nil {
		return m.Persist
	}
	return false
}

func (m *Message) GetProofHash() []byte {
	if m != nil {
		return m.ProofHash
	}
	return nil
}

type PayloadObject struct {
	Schema  string `protobuf:"bytes,1,opt,name=schema" json:"schema,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PayloadObject) Reset()                    { *m = PayloadObject{} }
func (m *PayloadObject) String() string            { return proto.CompactTextString(m) }
func (*PayloadObject) ProtoMessage()               {}
func (*PayloadObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *PayloadObject) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *PayloadObject) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// JEDIData contains extra information that must be signed and included with
// JEDI-encrypted messages.
type JEDIData struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *JEDIData) Reset()                    { *m = JEDIData{} }
func (m *JEDIData) String() string            { return proto.CompactTextString(m) }
func (*JEDIData) ProtoMessage()               {}
func (*JEDIData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *JEDIData) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type Payload struct {
	Objects []*PayloadObject `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
}

func (m *Payload) Reset()                    { *m = Payload{} }
func (m *Payload) String() string            { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()               {}
func (*Payload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Payload) GetObjects() []*PayloadObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

type SubscribeParams struct {
	Perspective *Perspective `protobuf:"bytes,1,opt,name=perspective" json:"perspective,omitempty"`
	Namespace   []byte       `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Uri         string       `protobuf:"bytes,3,opt,name=uri" json:"uri,omitempty"`
	// If specified, this proof will be used instead of building one for the
	// subscribe
	CustomProofDER []byte `protobuf:"bytes,4,opt,name=customProofDER,proto3" json:"customProofDER,omitempty"`
	// The unique identifier for the subscription. This enables you to resume
	// a previous subscription
	Identifier string `protobuf:"bytes,5,opt,name=identifier" json:"identifier,omitempty"`
	// How long should this queue last if not actively drained
	// Should be > 1 minute to prevent disconnect of live queues
	// This is in seconds
	Expiry int64 `protobuf:"varint,6,opt,name=expiry" json:"expiry,omitempty"`
	// What absolute time (nanoseconds UTC) should this subscription expire at
	// This is not normally used
	AbsoluteExpiry int64 `protobuf:"varint,7,opt,name=absoluteExpiry" json:"absoluteExpiry,omitempty"`
}

func (m *SubscribeParams) Reset()                    { *m = SubscribeParams{} }
func (m *SubscribeParams) String() string            { return proto.CompactTextString(m) }
func (*SubscribeParams) ProtoMessage()               {}
func (*SubscribeParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *SubscribeParams) GetPerspective() *Perspective {
	if m != nil {
		return m.Perspective
	}
	return nil
}

func (m *SubscribeParams) GetNamespace() []byte {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *SubscribeParams) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *SubscribeParams) GetCustomProofDER() []byte {
	if m != nil {
		return m.CustomProofDER
	}
	return nil
}

func (m *SubscribeParams) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *SubscribeParams) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *SubscribeParams) GetAbsoluteExpiry() int64 {
	if m != nil {
		return m.AbsoluteExpiry
	}
	return 0
}

type SubscriptionMessage struct {
	Error   *Error   `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Message *Message `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *SubscriptionMessage) Reset()                    { *m = SubscriptionMessage{} }
func (m *SubscriptionMessage) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionMessage) ProtoMessage()               {}
func (*SubscriptionMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *SubscriptionMessage) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SubscriptionMessage) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func init() {
	proto.RegisterType((*ConnectionStatusParams)(nil), "mqpb.ConnectionStatusParams")
	proto.RegisterType((*ConnectionStatusResponse)(nil), "mqpb.ConnectionStatusResponse")
	proto.RegisterType((*QueryParams)(nil), "mqpb.QueryParams")
	proto.RegisterType((*QueryMessage)(nil), "mqpb.QueryMessage")
	proto.RegisterType((*PeerQueryParams)(nil), "mqpb.PeerQueryParams")
	proto.RegisterType((*PeerUnsubscribeParams)(nil), "mqpb.PeerUnsubscribeParams")
	proto.RegisterType((*PeerUnsubscribeResponse)(nil), "mqpb.PeerUnsubscribeResponse")
	proto.RegisterType((*PeerPublishParams)(nil), "mqpb.PeerPublishParams")
	proto.RegisterType((*PeerPublishResponse)(nil), "mqpb.PeerPublishResponse")
	proto.RegisterType((*PeerSubscriptionTBS)(nil), "mqpb.PeerSubscriptionTBS")
	proto.RegisterType((*PeerSubscribeParams)(nil), "mqpb.PeerSubscribeParams")
	proto.RegisterType((*PublishParams)(nil), "mqpb.PublishParams")
	proto.RegisterType((*PublishResponse)(nil), "mqpb.PublishResponse")
	proto.RegisterType((*MessageTBS)(nil), "mqpb.MessageTBS")
	proto.RegisterType((*Message)(nil), "mqpb.Message")
	proto.RegisterType((*PayloadObject)(nil), "mqpb.PayloadObject")
	proto.RegisterType((*JEDIData)(nil), "mqpb.JEDIData")
	proto.RegisterType((*Payload)(nil), "mqpb.Payload")
	proto.RegisterType((*SubscribeParams)(nil), "mqpb.SubscribeParams")
	proto.RegisterType((*SubscriptionMessage)(nil), "mqpb.SubscriptionMessage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WAVEMQ service

type WAVEMQClient interface {
	Publish(ctx context.Context, in *PublishParams, opts ...grpc.CallOption) (*PublishResponse, error)
	Subscribe(ctx context.Context, in *SubscribeParams, opts ...grpc.CallOption) (WAVEMQ_SubscribeClient, error)
	Query(ctx context.Context, in *QueryParams, opts ...grpc.CallOption) (WAVEMQ_QueryClient, error)
	ConnectionStatus(ctx context.Context, in *ConnectionStatusParams, opts ...grpc.CallOption) (*ConnectionStatusResponse, error)
}

type wAVEMQClient struct {
	cc *grpc.ClientConn
}

func NewWAVEMQClient(cc *grpc.ClientConn) WAVEMQClient {
	return &wAVEMQClient{cc}
}

func (c *wAVEMQClient) Publish(ctx context.Context, in *PublishParams, opts ...grpc.CallOption) (*PublishResponse, error) {
	out := new(PublishResponse)
	err := grpc.Invoke(ctx, "/mqpb.WAVEMQ/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wAVEMQClient) Subscribe(ctx context.Context, in *SubscribeParams, opts ...grpc.CallOption) (WAVEMQ_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_WAVEMQ_serviceDesc.Streams[0], c.cc, "/mqpb.WAVEMQ/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &wAVEMQSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WAVEMQ_SubscribeClient interface {
	Recv() (*SubscriptionMessage, error)
	grpc.ClientStream
}

type wAVEMQSubscribeClient struct {
	grpc.ClientStream
}

func (x *wAVEMQSubscribeClient) Recv() (*SubscriptionMessage, error) {
	m := new(SubscriptionMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *wAVEMQClient) Query(ctx context.Context, in *QueryParams, opts ...grpc.CallOption) (WAVEMQ_QueryClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_WAVEMQ_serviceDesc.Streams[1], c.cc, "/mqpb.WAVEMQ/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &wAVEMQQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WAVEMQ_QueryClient interface {
	Recv() (*QueryMessage, error)
	grpc.ClientStream
}

type wAVEMQQueryClient struct {
	grpc.ClientStream
}

func (x *wAVEMQQueryClient) Recv() (*QueryMessage, error) {
	m := new(QueryMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *wAVEMQClient) ConnectionStatus(ctx context.Context, in *ConnectionStatusParams, opts ...grpc.CallOption) (*ConnectionStatusResponse, error) {
	out := new(ConnectionStatusResponse)
	err := grpc.Invoke(ctx, "/mqpb.WAVEMQ/ConnectionStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WAVEMQ service

type WAVEMQServer interface {
	Publish(context.Context, *PublishParams) (*PublishResponse, error)
	Subscribe(*SubscribeParams, WAVEMQ_SubscribeServer) error
	Query(*QueryParams, WAVEMQ_QueryServer) error
	ConnectionStatus(context.Context, *ConnectionStatusParams) (*ConnectionStatusResponse, error)
}

func RegisterWAVEMQServer(s *grpc.Server, srv WAVEMQServer) {
	s.RegisterService(&_WAVEMQ_serviceDesc, srv)
}

func _WAVEMQ_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WAVEMQServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mqpb.WAVEMQ/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WAVEMQServer).Publish(ctx, req.(*PublishParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _WAVEMQ_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WAVEMQServer).Subscribe(m, &wAVEMQSubscribeServer{stream})
}

type WAVEMQ_SubscribeServer interface {
	Send(*SubscriptionMessage) error
	grpc.ServerStream
}

type wAVEMQSubscribeServer struct {
	grpc.ServerStream
}

func (x *wAVEMQSubscribeServer) Send(m *SubscriptionMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _WAVEMQ_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WAVEMQServer).Query(m, &wAVEMQQueryServer{stream})
}

type WAVEMQ_QueryServer interface {
	Send(*QueryMessage) error
	grpc.ServerStream
}

type wAVEMQQueryServer struct {
	grpc.ServerStream
}

func (x *wAVEMQQueryServer) Send(m *QueryMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _WAVEMQ_ConnectionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectionStatusParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WAVEMQServer).ConnectionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mqpb.WAVEMQ/ConnectionStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WAVEMQServer).ConnectionStatus(ctx, req.(*ConnectionStatusParams))
	}
	return interceptor(ctx, in, info, handler)
}

var _WAVEMQ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mqpb.WAVEMQ",
	HandlerType: (*WAVEMQServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _WAVEMQ_Publish_Handler,
		},
		{
			MethodName: "ConnectionStatus",
			Handler:    _WAVEMQ_ConnectionStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _WAVEMQ_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Query",
			Handler:       _WAVEMQ_Query_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "wavemq.proto",
}

// Client API for WAVEMQPeering service

type WAVEMQPeeringClient interface {
	PeerPublish(ctx context.Context, in *PeerPublishParams, opts ...grpc.CallOption) (*PeerPublishResponse, error)
	PeerSubscribe(ctx context.Context, in *PeerSubscribeParams, opts ...grpc.CallOption) (WAVEMQPeering_PeerSubscribeClient, error)
	PeerUnsubscribe(ctx context.Context, in *PeerUnsubscribeParams, opts ...grpc.CallOption) (*PeerUnsubscribeResponse, error)
	PeerQueryRequest(ctx context.Context, in *PeerQueryParams, opts ...grpc.CallOption) (WAVEMQPeering_PeerQueryRequestClient, error)
}

type wAVEMQPeeringClient struct {
	cc *grpc.ClientConn
}

func NewWAVEMQPeeringClient(cc *grpc.ClientConn) WAVEMQPeeringClient {
	return &wAVEMQPeeringClient{cc}
}

func (c *wAVEMQPeeringClient) PeerPublish(ctx context.Context, in *PeerPublishParams, opts ...grpc.CallOption) (*PeerPublishResponse, error) {
	out := new(PeerPublishResponse)
	err := grpc.Invoke(ctx, "/mqpb.WAVEMQPeering/PeerPublish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wAVEMQPeeringClient) PeerSubscribe(ctx context.Context, in *PeerSubscribeParams, opts ...grpc.CallOption) (WAVEMQPeering_PeerSubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_WAVEMQPeering_serviceDesc.Streams[0], c.cc, "/mqpb.WAVEMQPeering/PeerSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &wAVEMQPeeringPeerSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WAVEMQPeering_PeerSubscribeClient interface {
	Recv() (*SubscriptionMessage, error)
	grpc.ClientStream
}

type wAVEMQPeeringPeerSubscribeClient struct {
	grpc.ClientStream
}

func (x *wAVEMQPeeringPeerSubscribeClient) Recv() (*SubscriptionMessage, error) {
	m := new(SubscriptionMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *wAVEMQPeeringClient) PeerUnsubscribe(ctx context.Context, in *PeerUnsubscribeParams, opts ...grpc.CallOption) (*PeerUnsubscribeResponse, error) {
	out := new(PeerUnsubscribeResponse)
	err := grpc.Invoke(ctx, "/mqpb.WAVEMQPeering/PeerUnsubscribe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wAVEMQPeeringClient) PeerQueryRequest(ctx context.Context, in *PeerQueryParams, opts ...grpc.CallOption) (WAVEMQPeering_PeerQueryRequestClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_WAVEMQPeering_serviceDesc.Streams[1], c.cc, "/mqpb.WAVEMQPeering/PeerQueryRequest", opts...)
	if err != nil {
		return nil, err
	}
	x := &wAVEMQPeeringPeerQueryRequestClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WAVEMQPeering_PeerQueryRequestClient interface {
	Recv() (*QueryMessage, error)
	grpc.ClientStream
}

type wAVEMQPeeringPeerQueryRequestClient struct {
	grpc.ClientStream
}

func (x *wAVEMQPeeringPeerQueryRequestClient) Recv() (*QueryMessage, error) {
	m := new(QueryMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for WAVEMQPeering service

type WAVEMQPeeringServer interface {
	PeerPublish(context.Context, *PeerPublishParams) (*PeerPublishResponse, error)
	PeerSubscribe(*PeerSubscribeParams, WAVEMQPeering_PeerSubscribeServer) error
	PeerUnsubscribe(context.Context, *PeerUnsubscribeParams) (*PeerUnsubscribeResponse, error)
	PeerQueryRequest(*PeerQueryParams, WAVEMQPeering_PeerQueryRequestServer) error
}

func RegisterWAVEMQPeeringServer(s *grpc.Server, srv WAVEMQPeeringServer) {
	s.RegisterService(&_WAVEMQPeering_serviceDesc, srv)
}

func _WAVEMQPeering_PeerPublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerPublishParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WAVEMQPeeringServer).PeerPublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mqpb.WAVEMQPeering/PeerPublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WAVEMQPeeringServer).PeerPublish(ctx, req.(*PeerPublishParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _WAVEMQPeering_PeerSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PeerSubscribeParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WAVEMQPeeringServer).PeerSubscribe(m, &wAVEMQPeeringPeerSubscribeServer{stream})
}

type WAVEMQPeering_PeerSubscribeServer interface {
	Send(*SubscriptionMessage) error
	grpc.ServerStream
}

type wAVEMQPeeringPeerSubscribeServer struct {
	grpc.ServerStream
}

func (x *wAVEMQPeeringPeerSubscribeServer) Send(m *SubscriptionMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _WAVEMQPeering_PeerUnsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerUnsubscribeParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WAVEMQPeeringServer).PeerUnsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mqpb.WAVEMQPeering/PeerUnsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WAVEMQPeeringServer).PeerUnsubscribe(ctx, req.(*PeerUnsubscribeParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _WAVEMQPeering_PeerQueryRequest_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PeerQueryParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WAVEMQPeeringServer).PeerQueryRequest(m, &wAVEMQPeeringPeerQueryRequestServer{stream})
}

type WAVEMQPeering_PeerQueryRequestServer interface {
	Send(*QueryMessage) error
	grpc.ServerStream
}

type wAVEMQPeeringPeerQueryRequestServer struct {
	grpc.ServerStream
}

func (x *wAVEMQPeeringPeerQueryRequestServer) Send(m *QueryMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _WAVEMQPeering_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mqpb.WAVEMQPeering",
	HandlerType: (*WAVEMQPeeringServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PeerPublish",
			Handler:    _WAVEMQPeering_PeerPublish_Handler,
		},
		{
			MethodName: "PeerUnsubscribe",
			Handler:    _WAVEMQPeering_PeerUnsubscribe_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PeerSubscribe",
			Handler:       _WAVEMQPeering_PeerSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PeerQueryRequest",
			Handler:       _WAVEMQPeering_PeerQueryRequest_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "wavemq.proto",
}

func init() { proto.RegisterFile("wavemq.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1032 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0x97, 0xef, 0xec, 0xd8, 0x37, 0x76, 0xfe, 0x74, 0x43, 0xdb, 0x8b, 0x09, 0xc5, 0xdc, 0x03,
	0x58, 0x20, 0xa2, 0xc8, 0x2d, 0x52, 0x91, 0x90, 0x50, 0x20, 0x16, 0x04, 0x88, 0x70, 0x37, 0x94,
	0x4a, 0xbc, 0xad, 0xcf, 0xdb, 0x64, 0xab, 0xdc, 0xed, 0x65, 0x77, 0xaf, 0xe0, 0x77, 0x3e, 0x45,
	0x5f, 0x78, 0xe1, 0x09, 0xc4, 0x87, 0xe0, 0x8b, 0x21, 0xb4, 0xbb, 0x77, 0xe7, 0xbb, 0xf3, 0x05,
	0x1a, 0xa4, 0xa2, 0xbe, 0x79, 0x7f, 0x33, 0xbb, 0x3b, 0xfb, 0xfb, 0xcd, 0xcc, 0x8d, 0x61, 0xf0,
	0x23, 0x79, 0x4e, 0xa3, 0xab, 0x83, 0x44, 0x70, 0xc5, 0x51, 0x3b, 0xba, 0x4a, 0xe6, 0x43, 0xa0,
	0x24, 0x61, 0x16, 0x09, 0x7c, 0xb8, 0xf3, 0x39, 0x8f, 0x63, 0x1a, 0x2a, 0xc6, 0xe3, 0x33, 0x45,
	0x54, 0x2a, 0x67, 0x44, 0x90, 0x48, 0x06, 0x73, 0xf0, 0xeb, 0x16, 0x4c, 0x65, 0xc2, 0x63, 0x49,
	0xd1, 0x3d, 0x00, 0xc5, 0x15, 0xb9, 0x9c, 0x51, 0x2a, 0xa4, 0xdf, 0x1a, 0xb5, 0xc6, 0x1d, 0x5c,
	0x42, 0xd0, 0xbb, 0xb0, 0x15, 0xda, 0xbd, 0x74, 0x61, 0x7d, 0x1c, 0xe3, 0x53, 0x43, 0x83, 0x17,
	0x2d, 0xe8, 0x3f, 0x4a, 0xa9, 0x58, 0xda, 0x3b, 0xd1, 0x7d, 0xe8, 0x27, 0x54, 0xc8, 0x44, 0x5f,
	0xfa, 0x9c, 0x9a, 0x83, 0xfb, 0x93, 0x5b, 0x07, 0x3a, 0xea, 0x83, 0xd9, 0xca, 0x80, 0xcb, 0x5e,
	0x68, 0x1f, 0xbc, 0x98, 0x44, 0x54, 0x26, 0x24, 0xa4, 0xe6, 0x9e, 0x01, 0x5e, 0x01, 0x68, 0x07,
	0xdc, 0x54, 0x30, 0xdf, 0x1d, 0xb5, 0xc6, 0x1e, 0xd6, 0x3f, 0x4d, 0x70, 0xa9, 0x54, 0x3c, 0x9a,
	0x09, 0xce, 0x9f, 0x1e, 0x4f, 0xb1, 0xdf, 0x36, 0x9b, 0x6a, 0x68, 0xf0, 0x03, 0x0c, 0x4c, 0x6c,
	0xa7, 0x54, 0x4a, 0x72, 0x4e, 0xd1, 0x3b, 0xd0, 0xa1, 0x42, 0x70, 0x91, 0x85, 0xd5, 0xb7, 0x61,
	0x4d, 0x35, 0x84, 0xad, 0x05, 0xbd, 0x07, 0xdd, 0xc8, 0x7a, 0x9b, 0x40, 0xfa, 0x93, 0x4d, 0xeb,
	0x94, 0x1d, 0x81, 0x73, 0x6b, 0xf0, 0x4b, 0x0b, 0xb6, 0x35, 0x05, 0xe5, 0xc7, 0x07, 0x30, 0x90,
	0x3c, 0x15, 0x21, 0x9d, 0xc6, 0x8a, 0xa9, 0xa5, 0xb9, 0x66, 0x80, 0x2b, 0xd8, 0x8d, 0xdf, 0xba,
	0x0f, 0x9e, 0x64, 0xe7, 0x31, 0x51, 0xa9, 0xa0, 0xd9, 0x33, 0x57, 0x00, 0x1a, 0x42, 0x2f, 0xc9,
	0x39, 0xe8, 0x18, 0x63, 0xb1, 0x0e, 0xbe, 0x86, 0xdb, 0x3a, 0xc0, 0xc7, 0xb1, 0x4c, 0xe7, 0x32,
	0x14, 0x6c, 0x4e, 0x6f, 0x10, 0xe6, 0x16, 0x38, 0x6c, 0x61, 0xe2, 0xf3, 0xb0, 0xc3, 0x16, 0xc1,
	0x27, 0x70, 0xb7, 0x76, 0x58, 0x91, 0x4a, 0xff, 0xce, 0x6a, 0xf0, 0x00, 0x6e, 0xe9, 0xdd, 0xb3,
	0x74, 0x7e, 0xc9, 0xe4, 0x45, 0x16, 0xc6, 0xdb, 0xe0, 0x46, 0xf2, 0x3c, 0xdb, 0x55, 0xa3, 0x59,
	0x5b, 0x82, 0x87, 0xb0, 0x5b, 0xda, 0x75, 0x93, 0xfb, 0xfe, 0x68, 0xd9, 0xad, 0x67, 0x36, 0xd8,
	0x44, 0x17, 0xc0, 0x77, 0x9f, 0x9d, 0xbd, 0x12, 0x81, 0x2c, 0x53, 0xed, 0x9c, 0x29, 0x2d, 0x89,
	0xe0, 0xa9, 0xa2, 0xe2, 0xe4, 0xd8, 0x48, 0xe2, 0xe1, 0x62, 0x8d, 0xee, 0xc0, 0x06, 0xfd, 0x29,
	0x61, 0x62, 0xe9, 0x6f, 0x8c, 0x5a, 0x63, 0x17, 0x67, 0xab, 0xe0, 0xd7, 0x6a, 0xbc, 0x85, 0x52,
	0x1f, 0x80, 0xab, 0xe6, 0x32, 0x7b, 0xe8, 0x5e, 0x5e, 0x45, 0x6b, 0xef, 0xc2, 0xda, 0xab, 0x9a,
	0x29, 0xce, 0x3f, 0x65, 0x8a, 0x5b, 0xcd, 0x14, 0x5d, 0x4f, 0x64, 0x2e, 0xf9, 0x65, 0xaa, 0xe8,
	0xd4, 0x86, 0xd7, 0x36, 0xe1, 0xd5, 0xd0, 0xe0, 0x4f, 0x07, 0x36, 0xab, 0x1a, 0xfe, 0x2f, 0xe5,
	0xfe, 0x21, 0x74, 0x43, 0x1e, 0x2b, 0x1a, 0x2b, 0xbf, 0x3d, 0x72, 0xc7, 0xfd, 0xc9, 0x6e, 0x76,
	0x01, 0x59, 0x5e, 0x72, 0xb2, 0xf8, 0x76, 0xfe, 0x8c, 0x86, 0x0a, 0xe7, 0x3e, 0xe8, 0x10, 0x76,
	0x69, 0x1c, 0x8a, 0xa5, 0x61, 0x67, 0x46, 0x84, 0x62, 0xfa, 0x87, 0xdf, 0x19, 0xb9, 0xe3, 0x01,
	0x6e, 0x32, 0x21, 0x1f, 0xba, 0x3a, 0x3e, 0x26, 0x95, 0xd1, 0xa5, 0x87, 0xf3, 0x65, 0x43, 0xa7,
	0xe9, 0x36, 0x75, 0x1a, 0x34, 0x86, 0xed, 0xec, 0xe0, 0x27, 0x4c, 0x5d, 0x7c, 0x35, 0x3d, 0x3e,
	0xf1, 0x7b, 0xe6, 0xa4, 0x3a, 0x1c, 0x3c, 0x80, 0xed, 0xff, 0x90, 0xd0, 0x2f, 0x1c, 0x80, 0xac,
	0x36, 0x5e, 0x36, 0x8f, 0x3f, 0x86, 0x2d, 0xbb, 0xfe, 0x86, 0x87, 0xc4, 0x30, 0xe0, 0x94, 0xd5,
	0xc9, 0xd1, 0xc7, 0xf8, 0x04, 0xd7, 0x1c, 0xab, 0x02, 0xb9, 0xd7, 0x08, 0xd4, 0xae, 0x08, 0x94,
	0x58, 0x2d, 0x0c, 0xcb, 0xd7, 0x09, 0x94, 0xf9, 0xe8, 0xe8, 0xb9, 0x60, 0xe7, 0x2c, 0xc6, 0xa6,
	0x2e, 0x0c, 0xe7, 0x1e, 0xae, 0x60, 0xe8, 0x7d, 0xe8, 0x3d, 0xa3, 0x0b, 0x76, 0x4c, 0x14, 0x31,
	0x94, 0xf7, 0x27, 0x5b, 0xf6, 0x4c, 0x4d, 0xa2, 0x46, 0x71, 0x61, 0x0f, 0x7e, 0x73, 0xa0, 0x5b,
	0x6a, 0xf1, 0x26, 0xad, 0xab, 0x5c, 0x1a, 0x9d, 0xb0, 0xb5, 0x54, 0x2a, 0xc1, 0xa9, 0x55, 0x42,
	0x60, 0x0b, 0xce, 0x35, 0x9b, 0x77, 0x2a, 0x3d, 0xa9, 0xb9, 0xce, 0xd6, 0x3a, 0xf2, 0xcd, 0xb3,
	0x4f, 0x7f, 0x8a, 0x59, 0x44, 0xa5, 0x22, 0x51, 0x22, 0xfd, 0x8d, 0x91, 0x3b, 0x76, 0x71, 0x09,
	0x41, 0x6f, 0x40, 0x67, 0x21, 0x78, 0x22, 0xfd, 0xae, 0x31, 0xd9, 0x45, 0x39, 0x67, 0x7b, 0xd5,
	0x9c, 0xdd, 0x07, 0xcf, 0xbc, 0xe7, 0x4b, 0x22, 0x2f, 0x7c, 0xcf, 0xc6, 0x57, 0x00, 0xc1, 0x11,
	0x6c, 0x56, 0x64, 0xd1, 0x3d, 0x49, 0x86, 0x17, 0x34, 0x22, 0x86, 0x32, 0x0f, 0x67, 0x2b, 0x7d,
	0x41, 0x5e, 0x75, 0x96, 0xa5, 0x7c, 0x19, 0x8c, 0xa1, 0x97, 0xab, 0xa0, 0x2f, 0x2b, 0x42, 0x35,
	0x07, 0xb8, 0x78, 0x05, 0x04, 0x0f, 0xa1, 0x9b, 0x5d, 0xa6, 0x73, 0x84, 0x9b, 0x0b, 0x75, 0x3b,
	0xbb, 0x3e, 0x47, 0x32, 0x9f, 0xe0, 0xaf, 0x16, 0x6c, 0xd7, 0xbb, 0xe1, 0xeb, 0x34, 0x5b, 0x68,
	0xd5, 0xd8, 0x82, 0xc6, 0x8a, 0x3d, 0x65, 0x54, 0x64, 0x8d, 0xbe, 0x84, 0x5c, 0xd7, 0xea, 0x1b,
	0x7a, 0x6d, 0xb7, 0xb1, 0xd7, 0x12, 0xd8, 0x2d, 0x77, 0xf9, 0x57, 0x30, 0xc2, 0x4c, 0x7e, 0x76,
	0x60, 0xe3, 0xc9, 0xd1, 0xf7, 0xd3, 0xd3, 0x47, 0xe8, 0x23, 0xe8, 0x66, 0x5d, 0x09, 0xe5, 0xba,
	0x94, 0xfb, 0xfc, 0xf0, 0x76, 0x05, 0x2c, 0x3a, 0xd7, 0xa7, 0xe0, 0x15, 0x22, 0xa1, 0xcc, 0xa7,
	0xa6, 0xda, 0x70, 0xaf, 0x02, 0x97, 0x1f, 0x73, 0xd8, 0x42, 0x87, 0xd0, 0x31, 0x03, 0x14, 0xca,
	0x64, 0x2c, 0x4d, 0x53, 0x43, 0x54, 0x82, 0x56, 0x3b, 0x66, 0xb0, 0x53, 0x1f, 0x6a, 0xd1, 0xbe,
	0xf5, 0x6c, 0x1e, 0x83, 0x87, 0xf7, 0x9a, 0xad, 0xf9, 0x23, 0x26, 0xbf, 0x3b, 0xb0, 0x69, 0x69,
	0xd0, 0x9f, 0x56, 0x16, 0x9f, 0xa3, 0x23, 0xe8, 0x97, 0x06, 0x0f, 0x74, 0x77, 0xf5, 0xe1, 0xad,
	0xb2, 0xb2, 0xb7, 0x66, 0x28, 0x98, 0xf9, 0x02, 0x36, 0x2b, 0x1f, 0x74, 0xb4, 0xfe, 0xf5, 0x7e,
	0x39, 0x86, 0x4e, 0xed, 0x98, 0x59, 0x1a, 0xbc, 0xd0, 0x9b, 0xab, 0xa3, 0xd6, 0x86, 0xbb, 0xe1,
	0x5b, 0x8d, 0xc6, 0x92, 0x62, 0x3b, 0xc5, 0xd4, 0x8a, 0xe9, 0x55, 0x4a, 0xa5, 0xca, 0x85, 0xab,
	0x4d, 0xb3, 0xcd, 0xfc, 0xcf, 0x37, 0xcc, 0xbf, 0x8e, 0xfb, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff,
	0xb5, 0x84, 0xa5, 0xb3, 0x97, 0x0c, 0x00, 0x00,
}
